//////////////////////////////////////////////////////////////////////////////
//
// File     :  mood_manager.skrit
// Author(s):  David Tomandl, James Loe
//
// Copyright © 2000 Gas Powered Games, Inc.  All rights reserved.
//----------------------------------------------------------------------------
//  $Revision:: $              $Date:$
//----------------------------------------------------------------------------
//NOTES:
//
// The old version is in mood_manager_old.  -J
//
///////////////////////////////////////////////////////////////////////	
// Here's our current system:
//
// We care about
// 1. Who the camera is pointing at (the camera's focus)
// 2. If that changed between the last time we checked and now
//
// If it hasn't changed, use the mood of the person that the camera is focused on
// If it has changed, instantly switch to the new person's mood
//////////////////////////////////////////////////////////////////////////////
// In addition, now the fog changes color based on the time of day.
// If the hour H :  13 <= H <= 17, fog gets 25% brighter (125% of original)
// If the hour H :  H = 5,6, or 23, fog gets 25% darker (75% of original)
// If the hour H :  0 <= H <= 4, fog gets 50% darker (50% of original)
// Otherwise, it's daytime, and the brightness of the fog stays at 100%.
//////////////////////////////////////////////////////////////////////////////
// The weather also randomly changes.  Generally, every 15 seconds there
// is a good chance of no change happening, or a small change.  There
// are small chances for a large change in the weather (20% or 30% difference
// in rain or snow density, for example).


//////////////////////////////////////////////////////////////////////////////
// public definitions

// reserved tags
property bool   _server_only$		= false;
property string _doc$				= "Controls mood management";


int LastFocused$					= -1;		// Track which party member is the focus
float Time$							= 0.0;		// This is to trigger time-based actions

int LastHour$						= -1;		// This will help track when the hour of day changes
string LastMood$					= "x";		// This will allow tracking of when the mood changes


//////////////////////////////////////////////////////////////////////////////
// Support Functions
//////////////////////////////////////////////////////////////////////////////

bool TurnWorldRed$()
{
	return GameAuditor.GetDb.GetBool( "turn_world_red" );
}

bool GetRandomBool$()
{
	return Math.RandomFloat( 1.0 ) > 0.5;
}

int GetModifiedFogColor$( int base_color$, int light_color$, float light_modifier$, float light_grayifier$, bool turn_red$ )
{
	int alphaFogComponent$, redFogComponent$, greenFogComponent$, blueFogComponent$;

	// split base color into components
	alphaFogComponent$	= base_color$ & 0xFF000000;
	redFogComponent$	= base_color$ & 0x00FF0000;
	greenFogComponent$	= base_color$ & 0x0000FF00;
	blueFogComponent$	= base_color$ & 0x000000FF;

	#only(game) [[
	// shift them over a bit
	redFogComponent$	= redFogComponent$ / 256 / 256;
	greenFogComponent$	= greenFogComponent$ / 256;

	// calculate light factors
	int redLightComponent$		= light_color$ & 0x00FF0000;
	int greenLightComponent$	= light_color$ & 0x0000FF00;
	int blueLightComponent$		= light_color$ & 0x000000FF;
	redLightComponent$		= redLightComponent$ / 256 / 256;
	greenLightComponent$	= greenLightComponent$ / 256;
	float redLightFactor$	= (float (redLightComponent$)) / 255;
	float greenLightFactor$	= (float (greenLightComponent$)) / 255;
	float blueLightFactor$	= (float (blueLightComponent$)) / 255;
	// tone down the saturation
	float avgLightFactor$ = (redLightFactor$ + greenLightFactor$ + blueLightFactor$) / 3;
	float lightColorFactor$ = 0.25;
	redLightFactor$		= (avgLightFactor$ * (1.0 - lightColorFactor$)) + (redLightFactor$ * lightColorFactor$);
	greenLightFactor$	= (avgLightFactor$ * (1.0 - lightColorFactor$)) + (greenLightFactor$ * lightColorFactor$);
	blueLightFactor$	= (avgLightFactor$ * (1.0 - lightColorFactor$)) + (blueLightFactor$ * lightColorFactor$);

	// calculate the new color
	float baseFactor$ = 1.25;
	float redFogFactor$		= (float (redFogComponent$)) / 255;
	float greenFogFactor$	= (float (greenFogComponent$)) / 255;
	float blueFogFactor$	= (float (blueFogComponent$)) / 255;
	redFogFactor$	*= baseFactor$ * redLightFactor$;
	greenFogFactor$	*= baseFactor$ * greenLightFactor$;
	blueFogFactor$	*= baseFactor$ * blueLightFactor$;

	// turn red
	if ( turn_red$ ) {
		redFogFactor$ = Math.MaxFloat(Math.MaxFloat(redFogFactor$, greenFogFactor$), blueFogFactor$);
		greenFogFactor$ = 0;
		blueFogFactor$ = 0;
	}

	// apply light modifier & grayifier
	float avgFogFactor$ = (redFogFactor$ + greenFogFactor$ + blueFogFactor$) / 3;
	redFogFactor$	= (avgFogFactor$ * light_grayifier$) + (redFogFactor$ * (1.0 - light_grayifier$));
	greenFogFactor$	= (avgFogFactor$ * light_grayifier$) + (greenFogFactor$ * (1.0 - light_grayifier$));
	blueFogFactor$	= (avgFogFactor$ * light_grayifier$) + (blueFogFactor$ * (1.0 - light_grayifier$));
	redFogFactor$	*= light_modifier$;
	greenFogFactor$	*= light_modifier$;
	blueFogFactor$	*= light_modifier$;

	// do bound checks
	redFogFactor$	= Math.MinFloat(Math.MaxFloat(redFogFactor$,	0.0), 1.0);
	greenFogFactor$	= Math.MinFloat(Math.MaxFloat(greenFogFactor$,	0.0), 1.0);
	blueFogFactor$	= Math.MinFloat(Math.MaxFloat(blueFogFactor$,	0.0), 1.0);

	// convert back to integer component values
	redFogComponent$	= int (redFogFactor$	* 255);
	greenFogComponent$	= int (greenFogFactor$	* 255);
	blueFogComponent$	= int (blueFogFactor$	* 255);
	// shift them over a bit
	redFogComponent$ = redFogComponent$ * 256 * 256;
	greenFogComponent$ = greenFogComponent$ * 256;
	]];

	// combine components into final color
	return alphaFogComponent$ | redFogComponent$ | greenFogComponent$ | blueFogComponent$;
}

int InvertColor$( int color$ )
{
	int alpha$, red$, green$, blue$;

	// setup the base values
	alpha$	= color$ & 0xFF000000;
	red$	= color$ & 0x00FF0000;
	green$	= color$ & 0x0000FF00;
	blue$	= color$ & 0x000000FF;

	#only(game) [[
	// shift them over a bit
	red$	= red$ / 256 / 256;
	green$	= green$ / 256;

	// invert the values
	red$	= 255 - red$;
	green$	= 255 - green$;
	blue$	= 255 - blue$;

	// shift them over a bit
	red$ = red$ * 256 * 256;
	green$ = green$ * 256;
	]];

	// and find the new one
	return alpha$ | red$ | green$ | blue$;
}

int GetCurrentHourLightColor$( int currentHour$, bool isSnowEnabled$ )
{
	if (!isSnowEnabled$)
	{
		// see timeofday.gas
		if (currentHour$ ==  0) { return 0xFF9E4DCA; }
		if (currentHour$ ==  1) { return 0xFF000040; }
		if (currentHour$ ==  2) { return 0xFF000020; }
		if (currentHour$ ==  3) { return 0xFF000000; }
		if (currentHour$ ==  4) { return 0xFF000010; }
		if (currentHour$ ==  5) { return 0xFFA4700F; }
		if (currentHour$ ==  6) { return 0xFFA4700F; }
		if (currentHour$ ==  7) { return 0xFFE0A54B; }
		if (currentHour$ ==  8) { return 0xFFE0A54B; }
		if (currentHour$ ==  9) { return 0xFFE0C24B; }
		if (currentHour$ == 10) { return 0xFFE0C24B; }
		if (currentHour$ == 11) { return 0xFFF5F19A; }
		if (currentHour$ == 12) { return 0xFFF5F19A; }
		if (currentHour$ == 13) { return 0xFFF8FBD7; }
		if (currentHour$ == 14) { return 0xFFF8FBD7; }
		if (currentHour$ == 15) { return 0xFFF8FBD7; }
		if (currentHour$ == 16) { return 0xFFF8FBD7; }
		if (currentHour$ == 17) { return 0xFFF8FBD7; }
		if (currentHour$ == 18) { return 0xFFF5F19A; }
		if (currentHour$ == 19) { return 0xFFF5F19A; }
		if (currentHour$ == 20) { return 0xFFE0C24B; }
		if (currentHour$ == 21) { return 0xFFE0C24B; }
		if (currentHour$ == 22) { return 0xFFE0A54B; }
		if (currentHour$ == 23) { return 0xFFA4700F; }
	}
	else
	{
		// see any of the original snow moods
		if (currentHour$ <=  0) { return 0xFF000000; }
		if (currentHour$ <=  5) { return 0xFF1A1A00; }
		if (currentHour$ <=  6) { return 0xFF66330D; }
		if (currentHour$ <=  7) { return 0xFFB39A40; }
		if (currentHour$ <=  8) { return 0xFFB3B3B3; }
		if (currentHour$ <= 10) { return 0xFFF0F0FF; }
		if (currentHour$ <= 12) { return 0xFFFFFFFF; }
		if (currentHour$ <= 19) { return 0xFFB39A9A; }
		if (currentHour$ <= 20) { return 0xFF66334D; }
		if (currentHour$ <= 21) { return 0xFF330D40; }
		if (currentHour$ <= 22) { return 0xFF000000; }
		if (currentHour$ <= 23) { return 0xFF000000; }
	}
	return 0.0;
}

float GetChangedWeatherValue$( float weather_baseline$, float weather_current$ )
{
	float weatherModifier$;

	// more or less weather?
	if ( GetRandomBool$() ) { weatherModifier$ = 1.0; }
	else { weatherModifier$ = -1.0; }

	// how much more or less?
	float randomNumber$ = math.randomfloat( 1.0 );
	// 80% chance of 10% weather change
	// 10% chance of 20% weather change
	// 6% chance of 30% weather change
	// 4% chance of 50% weather change
	if (randomNumber$ < 0.8) { weatherModifier$ *= 0.1; }
	else if (randomNumber$ < 0.9) { weatherModifier$ *= 0.2; }
	else if (randomNumber$ < 0.96) { weatherModifier$ *= 0.3; }
	else { weatherModifier$ *= 0.5; }

	// find the new current weather
	weather_current$ += weather_baseline$ * weatherModifier$;

	// This will keep the weather from becoming too different from the base mood
	if (weather_current$ < (weather_baseline$ * 0.5) ) { weather_current$ = (weather_baseline$ * 0.5); }
	if (weather_current$ > (weather_baseline$ * 1.5) ) { weather_current$ = (weather_baseline$ * 1.5); }

	return weather_current$;
}

void ChangeRain$( Goid focusedGo$ )
{
	float rainCurrent$ = Mood.GetGoMoodSetting( focusedGo$ ).rainDensity;
	// This is the original rain density
	float rainBaseline$ = Mood.GetOriginalMoodSetting( Mood.GetGoRequestedMood( focusedGo$ ) ).rainDensity;

	rainCurrent$ = GetChangedWeatherValue$( rainBaseline$, rainCurrent$ );

	// This applies the changes
	Mood.GetGoMoodSetting( focusedGo$ ).rainDensity = rainCurrent$;
	Mood.ForceUpdateRain(0);

	//report.genericF("Rain density is now %f, base rain is %f\n", rainCurrent$, rainBaseline$);
}

void ChangeSnow$( Goid focusedGo$ )
{
	float snowCurrent$ = Mood.GetGoMoodSetting( focusedGo$ ).snowDensity;
	// This is the original snow density
	float snowBaseline$ = Mood.GetOriginalMoodSetting( Mood.GetGoRequestedMood( focusedGo$ ) ).snowDensity;

	snowCurrent$ = GetChangedWeatherValue$( snowBaseline$, snowCurrent$ );

	// This applies the changes
	Mood.GetGoMoodSetting( focusedGo$ ).snowDensity = snowCurrent$;
	Mood.ForceUpdateSnow(0);

	//report.genericF("Snow density is now %f, base snow is %f\n", snowCurrent$, snowBaseline$);
}

void ChangeWind$( Goid focusedGo$ )
{
	float windCurrent$ = Mood.GetGoMoodSetting( focusedGo$ ).windVelocity;
	// This is the original wind velocity
	float windBaseline$ = Mood.GetOriginalMoodSetting( Mood.GetGoRequestedMood( focusedGo$ ) ).windVelocity;

	windCurrent$ = GetChangedWeatherValue$( windBaseline$, windCurrent$ );

	// This applies the changes
	Mood.GetGoMoodSetting( focusedGo$ ).windVelocity = windCurrent$;
	Mood.ForceUpdateWind(0);

	//report.genericF("Wind velocity is now %f, base wind is %f\n", windCurrent$, windBaseline$);
}

void ChangeWeather$( Goid focusedGo$ )
{
	// If it's raining, the rain will change
	if (Mood.GetGoMoodSetting( focusedGo$ ).bRainEnabled)
	{
		ChangeRain$( focusedGo$ );
	}

	// If it's snowing, the snow will change
	if (Mood.GetGoMoodSetting( focusedGo$ ).bSnowEnabled)
	{
		ChangeSnow$( focusedGo$ );
	}

	// If it's windy, the wind will change
	if (Mood.GetGoMoodSetting( focusedGo$ ).bWindEnabled)
	{
		ChangeWind$( focusedGo$ );
	}
}

void DynamicWeatherChange$( Goid focusedGo$, float secondsElapsed$ )
{
	Time$ += secondsElapsed$;

	if ( Time$ > 15.0 ) // time to see if the weather is going to change
	{
		Time$ = 0.0;

		//report.generic( "I'm going to see if I should change the weather.\n" );
		float randomNumber$ = math.randomfloat( 1.0 );
		// 40% of the time, the weather will not change
		if (randomNumber$ > 0.4)
		{
			//report.generic( "Yep, I'm changing the weather.\n" );
			ChangeWeather$( focusedGo$ );
		}
	}

	bool isInterior$ = Mood.GetGoMoodSetting( focusedGo$ ).bInterior;

	// Switch lightning on or off
	bool shouldHaveLightning$ = Mood.GetOriginalMoodSetting( Mood.GetGoRequestedMood( focusedGo$ ) ).bLightning;
	// completely ignore original mood setting, base it on rainDensity instead
	shouldHaveLightning$ = Mood.GetGoMoodSetting( focusedGo$ ).rainDensity > 200;
	if ( TurnWorldRed$() && (!isInterior$) )
	{
		shouldHaveLightning$ = true;
	}
	if ( Mood.GetGoMoodSetting( focusedGo$ ).bLightning != shouldHaveLightning$ )
	{
		Mood.GetGoMoodSetting( focusedGo$ ).bLightning = shouldHaveLightning$;
		Mood.ForceUpdateRain(0); // This applies the change
		//report.genericF("Rain density is now %f, turned off lightning.\n", Mood.GetGoMoodSetting( focusedGo$ ).rainDensity);
	}
}

void DynamicFogChange$( Goid focusedGo$ )
{
	// change the color of the fog based on the time of day.
	int currentHour$ = TimeOfDay.GetHour();
	string currentMood$ = Mood.GetGoRequestedMood( focusedGo$ ); // Get the name of the current mood
	if ( (currentHour$ != LastHour$) || (currentMood$ != LastMood$ ) )
	{
		// Fog color should change with time of day...but not if they are inside.  
		int newFogColor$;
		bool isInterior$ = Mood.GetGoMoodSetting( focusedGo$ ).bInterior;

		// get the base color, store the old color and get ready to receive a new one
		int baseFogColor$ = Mood.GetOriginalMoodSetting( Mood.GetGoRequestedMood( focusedGo$ ) ).fogColor;
		int oldFogColor$ = Mood.GetGoMoodSetting( focusedGo$ ).fogColor;

		// find the new light modifier
		float light_modifier$ = 1;
		float light_grayifier$ = 0;
		int light_color$ = 0xFFFFFFFF;
		if (!isInterior$)
		{
			bool isSnowEnabled$ = Mood.GetGoMoodSetting( focusedGo$ ).bSnowEnabled;
			light_color$ = GetCurrentHourLightColor$( currentHour$, isSnowEnabled$ );
			if ( TurnWorldRed$() )
			{
				light_color$ = InvertColor$( light_color$ );
			}
		}
		bool isHeavyRain$ = Mood.GetGoMoodSetting( focusedGo$ ).bRainEnabled && (Mood.GetGoMoodSetting( focusedGo$ ).rainDensity > 200);
		if ( isHeavyRain$ ) { light_grayifier$ += 0.15; light_modifier$ -= 0.15; }  // Heavy rain darkens the fog by -15%
		bool isHeavySnow$ = Mood.GetGoMoodSetting( focusedGo$ ).bSnowEnabled && (Mood.GetGoMoodSetting( focusedGo$ ).snowDensity > 200);
		if ( isHeavySnow$ ) { light_grayifier$ += 0.15; light_modifier$ += 0.15; }  // Heavy snow brightens the fog by +15%

		// get the new fog color
		newFogColor$ = GetModifiedFogColor$( baseFogColor$, light_color$, light_modifier$, light_grayifier$, TurnWorldRed$() );
		//report.genericf( "Fog base / last / new : 0x%x / 0x%x / 0x%x.\n", baseFogColor$, oldFogColor$, newFogColor$);

		Mood.GetGoMoodSetting( focusedGo$ ).fogColor = newFogColor$; // apply changes

		// If the mood just changed, the engine will update the fog color to the value that we just created.
		// If the mood has not changed, we have to prompt it to update.
		if (( LastMood$ == currentMood$ ) && (oldFogColor$ != newFogColor$)) { Mood.ForceUpdateFog( 15.0 ); }

		LastMood$ = currentMood$; // cleanup
		LastHour$ = currentHour$; // cleanup
	}
}

void DoManageMoods$( Goid focusedGo$, float secondsElapsed$ )
{
	DynamicWeatherChange$( focusedGo$, secondsElapsed$ );

	DynamicFogChange$( focusedGo$ );
}


//////////////////////////////////////////////////////////////////////////////

ManageMoods$( GoidColl partyMembers$, bool /*instantSwitch$*/, float secondsElapsed$ )
{
	Goid focusedGo$; 	// get the focused go

	int newFocused$;	// the number of the party member that is focused

	// Run through the party looking for the person with the focus
	int i$ = 0;
	while( i$ < partyMembers$.Size() )
	{
		if(partyMembers$.Get( i$ ).GetGo.IsFocused())
		{
			focusedGo$ = partyMembers$.Get( i$ );
			newFocused$ = i$; //once we find it, record which number they are
		}
		i$ += 1;
	}

	float transitionTime$ = Mood.GetGoMoodSetting( focusedGo$ ).transitionTime;

	// If the focus has changed, and the mood is different, instantly switch to the new mood

	// We can't get the mood of the last focused mood if this if the first time we have tried to manage moods.
	// We don't want to try and get a party member that doesn't exist, thus this check  --DT

	if ( ( LastFocused$ < 0 ) || ( LastFocused$ >= partyMembers$.Size() ) ) // if this is the first time through, OR we just disbanded a party member
	{
		transitionTime$ = 0;	
	} 
	else if ( newFocused$ != LastFocused$ )
	{	
		if ( Mood.GetGoRequestedMood( partyMembers$.Get( newFocused$ ) ) != Mood.GetGoRequestedMood( partyMembers$.Get( LastFocused$ ) ) )
		{
			transitionTime$ = 0;
		}
	}
	LastFocused$ = newFocused$;


	// Time to play with weather
	DoManageMoods$( focusedGo$, secondsElapsed$ );


	// Set the focused go as the active go for all mood components
	Mood.SetActiveSunGo( focusedGo$, transitionTime$ );
	Mood.SetActiveFogGo( focusedGo$, transitionTime$ );
	Mood.SetActiveRainGo( focusedGo$, transitionTime$ );
	Mood.SetActiveSnowGo( focusedGo$, transitionTime$ );
	Mood.SetActiveWindGo( focusedGo$, transitionTime$ );
	Mood.SetActiveMusicGo( focusedGo$, transitionTime$ );

	// Always play ambient theme and standard music
	Mood.PlayAmbientTrack( 0.0 );
	Mood.PlayStandardTrack( 0.0 );
}

//////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
**							DOCUMENTATION									**
******************************************************************************

	// If you need to retrieve information about a mood, use the following:

	Mood.GetGoRequestedMood( goid );			// Get the name of the mood requested by this GO
	Mood.GetGoMoodSetting( goid );				// Get the setting requested by the GO
	Mood.GetMoodSetting( moodName );			// Get the setting for the mood of this name

	// You can manually activate a mood by name by doing:

	Mood.SetMood( moodName, transTime );		// Transition to the given mood over transTime

	// Or you can activate individual mood components directly from
	// the GO by doing:

	Mood.SetActiveSunGo( goid, transTime );		// Set the active sun mood to this GO's mood, transitioning over transTime
	Mood.SetActiveFogGo( goid, transTime );		// Set the active fog mood to this GO's mood, transitioning over transTime
	Mood.SetActiveRainGo( goid, transTime );	// Set the active rain mood to this GO's mood, transitioning over transTime
	Mood.SetActiveSnowGo( goid, transTime );	// Set the active snow mood to this GO's mood, transitioning over transTime
	Mood.SetActiveWindGo( goid, transTime );	// Set the active wind mood to this GO's mood, transitioning over transTime
	Mood.SetActiveMusicGo( goid, transTime );	// Set the active music mood to this GO's mood, transitioning over transTime

	// You can retreive information about the GO's that are currently
	// controlling different parts of the mood by calling:

	Mood.GetActiveSunGo();						// Get the active sun GO
	Mood.GetActiveFogGo();						// Get the active fog GO
	Mood.GetActiveRainGo();						// Get the active rain GO
	Mood.GetActiveSnowGo();						// Get the active snow GO
	Mood.GetActiveWindGo();						// Get the active wind GO
	Mood.GetActiveMusicGo();					// Get the active music GO

	// By default, all music is disabled.  To play any tracks, you must specify the tracks
	// to play and the time to fade the track in.  For example, to fade in a theme:

	Mood.PlayStandardTrack( 0.0 );				// Instantly start playing the standard theme
	Mood.PlayBattleTrack( 2.0 );				// Fade in battle theme over 2 seconds
	Mood.PlayAmbientTrack( 10.0 );				// Fade in ambient theme over 10 seconds

	// Once you have started a theme, you are also responsible for stopping it.  To fade out
	// the theme, you would do:

	Mood.StopStandardTrack( 1.0 );				// Fade out standard theme over 1 second
	Mood.StopBattleTrack( 0.0 );				// Instantly stop playing the battle theme
	Mood.StopAmbientTrack( 2.0 );				// Fade our ambient theme of 2 seconds

	// In many cases, you may need to determine if a theme is playing.  To do this:

	Mood.IsStandardTrackPlaying();				// See if standard track is currently playing or not
	Mood.IsBattleTrackPlaying();				// See if battle track is currently playing or not
	Mood.IsAmbientTrackPlaying();				// See if ambient track is currently playing or not

******************************************************************************
**							END DOCUMENTATION								**
*****************************************************************************/